<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>AR Horizon Scanner</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    
    <style>
      :root { --safe-top: env(safe-area-inset-top); --safe-bottom: env(safe-area-inset-bottom); }
      body { margin: 0; overflow: hidden; font-family: -apple-system, sans-serif; background: #000; }

      /* Estado Superior */
      .ui-header { 
        position: fixed; top: 0; left: 0; right: 0; z-index: 1000; 
        background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(10px);
        padding: calc(15px + var(--safe-top)) 20px 15px 20px;
        text-align: center; border-bottom: 1px solid rgba(255,255,255,0.2);
      }
      .radar-title { color: white; font-weight: 800; font-size: 16px; letter-spacing: 2px; opacity: 0.8; }

      /* NOTIFICACIÓN DE PUEBLO DETECTADO */
      .detection-overlay {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        z-index: 1000; width: 85%; pointer-events: none; text-align: center;
      }
      
      .town-name {
        font-size: 42px; font-weight: 900; color: #FF9500;
        text-shadow: 0 0 20px rgba(0,0,0,0.8), 0 0 10px rgba(255,149,0,0.5);
        opacity: 0; transition: opacity 0.2s ease, transform 0.2s ease;
        transform: scale(0.8); text-transform: uppercase;
      }
      
      .town-name.visible { opacity: 1; transform: scale(1); }

      .distance-info {
        color: white; font-size: 18px; font-weight: 600; margin-top: 10px;
        background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 20px;
        display: inline-block; opacity: 0; transition: opacity 0.2s;
      }
      .distance-info.visible { opacity: 1; }

      /* Guía visual central */
      .scanner-line {
        position: fixed; top: 50%; left: 0; right: 0; height: 2px;
        background: linear-gradient(90deg, transparent, #FF9500, transparent);
        z-index: 999; opacity: 0.4;
      }
    </style>
  </head>

  <body>
    <div class="ui-header">
      <div class="radar-title">ESCÁNER DE HORIZONTE ACTIVO</div>
    </div>

    <div class="scanner-line"></div>

    <div class="detection-overlay">
      <div id="town-display" class="town-name">BUSCANDO...</div>
      <br>
      <div id="dist-display" class="distance-info">---</div>
    </div>

    <a-scene vr-mode-ui="enabled: false" embedded arjs="sourceType: webcam; debugUIEnabled: false; videoTexture: true;">
      <a-camera gps-camera rotation-reader></a-camera>
    </a-scene>

    <script>
      let pueblos = [];
      const display = document.getElementById('town-display');
      const distDisplay = document.getElementById('dist-display');

      // 1. Localizar y buscar pueblos en un radio de 30km
      navigator.geolocation.getCurrentPosition((pos) => {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        fetchPueblos(lat, lon);
        
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission();
        }
        window.addEventListener('deviceorientation', scanHorizon, true);
      });

      async function fetchPueblos(lat, lon) {
        // Buscamos núcleos urbanos en 30km
        const query = `[out:json];node(around:30000,${lat},${lon})["place"~"city|town|village|hamlet"];out 15;`;
        const url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

        try {
          const res = await fetch(url);
          const data = await res.json();
          pueblos = data.elements.map(el => ({
            name: el.tags.name ? el.tags.name.toUpperCase() : "PUEBLO DESCONOCIDO",
            lat: el.lat,
            lon: el.lon,
            dist: 0
          }));
        } catch (e) { console.error("Error cargando datos geográficos"); }
      }

      function scanHorizon(e) {
        if (pueblos.length === 0) return;

        let heading = e.webkitCompassHeading || (360 - e.alpha);
        let puebloDetectado = null;
        let minimaDistanciaAngular = 12; // Sensibilidad de la mirada (grados)

        navigator.geolocation.getCurrentPosition((pos) => {
          const uLat = pos.coords.latitude;
          const uLon = pos.coords.longitude;

          pueblos.forEach(p => {
            const y = Math.sin(toRadians(p.lon - uLon)) * Math.cos(toRadians(p.lat));
            const x = Math.cos(toRadians(uLat)) * Math.sin(toRadians(p.lat)) -
                      Math.sin(toRadians(uLat)) * Math.cos(toRadians(p.lat)) * Math.cos(toRadians(p.lon - uLon));
            const bearing = (toDegrees(Math.atan2(y, x)) + 360) % 360;

            const diff = Math.abs((bearing - heading + 540) % 360 - 180);

            if (diff < minimaDistanciaAngular) {
              puebloDetectado = p;
              p.dist = calcDist(uLat, uLon, p.lat, p.lon);
            }
          });

          if (puebloDetectado) {
            display.innerText = puebloDetectado.name;
            display.classList.add('visible');
            distDisplay.innerText = puebloDetectado.dist.toFixed(1) + " KM EN ESTA DIRECCIÓN";
            distDisplay.classList.add('visible');
            // Vibración suave al detectar
            if (!display.dataset.last || display.dataset.last !== puebloDetectado.name) {
                window.navigator.vibrate(50);
                display.dataset.last = puebloDetectado.name;
            }
          } else {
            display.classList.remove('visible');
            distDisplay.classList.remove('visible');
            display.dataset.last = "";
          }
        });
      }

      // Utilidades matemáticas
      function toRadians(d) { return d * Math.PI / 180; }
      function toDegrees(r) { return r * 180 / Math.PI; }
      function calcDist(l1, n1, l2, n2) {
        const R = 6371;
        const dL = toRadians(l2-l1); const dN = toRadians(n2-n1);
        const a = Math.sin(dL/2)**2 + Math.cos(toRadians(l1))*Math.cos(toRadians(l2))*Math.sin(dN/2)**2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      }
    </script>
  </body>
</html>